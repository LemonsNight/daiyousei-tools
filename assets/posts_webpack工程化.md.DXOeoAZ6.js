import{_ as t,c as a,o as s,a as e,e as o}from"./chunks/framework.DjX62oqG.js";const E=JSON.parse('{"title":"vue3 reactive 解析","description":"","frontmatter":{"title":"vue3 reactive 解析","tags":["vue","前端"],"cover":"/vitepress-theme-sakura/60651947_p0.jpg","date":"2023-05-02T00:00:00.000Z"},"headers":[],"relativePath":"posts/webpack工程化.md","filePath":"posts/webpack工程化.md"}'),c={name:"posts/webpack工程化.md"},n=e("h2",{id:"webpack和vite有什么区别",tabindex:"-1"},[o("webpack和vite有什么区别？ "),e("a",{class:"header-anchor",href:"#webpack和vite有什么区别","aria-label":'Permalink to "webpack和vite有什么区别？"'},"​")],-1),i=e("p",null,"vite: 采用的是 ES 模块，在构建的时候，已经确定了文件之间的依赖关系，",-1),p=e("p",null,"不需要在运行时去做动态解析，由于 ES 的依赖关系在代码编写时已知，浏览器可以并行加载多个模块，而不必等待前一个模块加载完成后再加载下一个模块。这种并行加载的特性可以显著提高在多依赖项目的加载速度。",-1),r=e("p",null,"ESM 具有内置的缓存机制，可以避免重复加载已经加载过的模块，从而减少了不必要的网络请求和资源消耗。",-1),_=e("p",null,"相对于传统的模块格式，ESM 更加轻量级，不需要像 CommonJS 那样进行额外的封装和包装，因此在解析和执行时更加高效。",-1),l=e("p",null,"这些因素使得在适当的情况下，使用 ESM 的应用程序在加载和执行速度上可以比使用传统的模块格式更快。在 Vite 中，利用了这些优势，通过原生 ES 模块的加载和解析来实现快速的开发启动和热模块替换。",-1),d=e("p",null,"webpack: 把整个项目视为一个模块，通过 loader（加载器） 和 plugins（插件） 对代码转换，对于大型项目，首次加载会慢一点",-1),h=[n,i,p,r,_,l,d];function u(v,k,m,b,f,w){return s(),a("div",null,h)}const x=t(c,[["render",u]]);export{E as __pageData,x as default};
